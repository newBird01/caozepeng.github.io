(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{642:function(e,a,t){"use strict";t.r(a);var l=t(26),i=Object(l.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[e._v("#")]),e._v(" Webpack")]),e._v(" "),t("h2",{attrs:{id:"webpack是啥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack是啥"}},[e._v("#")]),e._v(" webpack是啥")]),e._v(" "),t("p",[e._v("webpack是模块打包工具，本身只支持js文件的打包，如果打包其他文件则需要对应的loader进行处理。而额外的按需加载，压缩等需要插件进行实现。")]),e._v(" "),t("h2",{attrs:{id:"打包原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包原理"}},[e._v("#")]),e._v(" 打包原理")]),e._v(" "),t("ol",[t("li",[e._v("执行.bin/webpack")]),e._v(" "),t("li",[e._v("执行 node_modules/webpack-cli/bin/cli.js\n"),t("ul",[t("li",[e._v("执行 processOptions")]),e._v(" "),t("li",[e._v("执行 compiler = webpack(options);\n"),t("ul",[t("li",[e._v("遍历默认插件，并调用 plugin.apply(compiler);")]),e._v(" "),t("li",[e._v("compiler = new Compiler(options.context);")]),e._v(" "),t("li",[e._v("return compiler")])])])])]),e._v(" "),t("li",[e._v("从入口文件开始解析，并遍历分析依赖，形成依赖树")]),e._v(" "),t("li",[e._v("对不同的文件使用对应的loader进行编译，转为js文件")]),e._v(" "),t("li",[e._v("整个编译过程会触发不同的钩子，钩子可以被插件监听，从而干涉处理结果")])]),e._v(" "),t("p",[e._v("compiler对象是一个全局单例，他负责把控整个webpack打包的构建流程。compilation对象是每一次构建的上下文对象，它包含了当次构建所需要的所有信息，每次热更新和重新构建，compiler都会重新生成一个新的compilation对象，负责此次更新的构建过程。")]),e._v(" "),t("p",[e._v("而每个模块间的依赖关系，则依赖于AST语法树。每个模块文件在通过Loader解析完成之后，会通过acorn库生成模块代码的AST语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。")])])}),[],!1,null,null,null);a.default=i.exports}}]);